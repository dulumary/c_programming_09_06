# 7. 배열    

## 여러개의 변수

*  열개의 점수를 변수에 넣고 평균을 구하세요. 

```
int socre1 = 89;
int socre2 = 93;
int socre3 = 91;
int socre4 = 93;
int socre5 = 92;
int socre6 = 78;
int socre7 = 90;
int socre8 = 90;
int socre9= 93;
int socre10= 90;

float average = (score1 + score2 + score3 + score4 + score5 + score6 + score7 + score8 + score9 + score10) / 10; 
```
* 위 와 같이 같은 속성을 가진 여러개의 변수를 사용 하는 경우가 생긴다. 
* 각 변수를 모두 다른 변수로 저장 할 경우 라인수도 많아져서 가독성이 떨어진다. 
* 변수 작명에도 힘들어지고, 실수를 하기도 쉬워지고, 실수를 찾기도 어렵다. 


## 배열 (Array)

* 위 소스의 변수 부분을 다르게 표현 하면 아래와 같다. 

```
int scores[10] = {89, 93, 91, 93, 92, 78, 90, 90, 93, 90};
```

* 이와 같은 형태를 **배열**, **Array** 라고 한다.
* 하나의 변수 이름에 여러개의 값을 저장 할수 있다. 
* 변수명 뒤에 [ ] 표시하고 그안에 저장할 값의 개수를 넣는다. 
* 변수가 하나의 상자에 들어 있는 숫자라면 배열은 아래와 같이 여러 상자를 이어 놓은 형태이다. 
* 실제로 메모리에도 아래와 같이 연속되게 저장된다.

	| 89 | 93 | 91 | 93 | 92 | 78 | 90 | 90 | 93 | 90 |
	|----|----|----|----|----|----|----|----|----|----|   
	
* 값을 초기화, 할때는 {} 안에 넣을 데이터를 ,(쉼표)로 구분해서 넣어 준다. 
* 초기화 할 값이 없을떄 아래와 같은 형태로 초기화 하면 모두 0으로 초기화 된다. 


```
int scores[10] = {0, };
```
* 일부 값만 넣고 나머지를 초기화 할때는 아래와 같이 한다. 

```
int scores[10] = {89, 93, 91, };
```

## 배열 값 접근

```
int scores[10] = {89, 93, 91, 93, 92, 78, 90, 90, 93, 90};

printf("첫번째 값은 %d 입니다.", scores[0]);
printf("두번째 값은 %d 입니다.", scores[1]);
printf("세번째 값은 %d 입니다.", scores[2]);
...

printf("열번째 값은 %d 입니다.", scores[9]);
```
| [0] | [1] | [2] | [3] | [4] | [5] | [6] | [7] | [8] | [9] |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 89  | 93  | 91  | 93  | 92  | 78  | 90  | 90  | 93  | 90  |

* 배열의 값을 이용 할 때는 scores[0] 의 형태로 몇 번째 데이터에 접근할지를 나타낸다. 
* [] 안에 들어 가는 숫자를 **index** 라고 한다. 
* index는 0부터 시작 되고,  (배열 개수 - 1)만큼 유효하다. 
	* 0 부터 시작 되는 것을 꼭 주의 해야 한다. 
	* 배열의 크기보다 큰 index에 접근하는 경우 프로그램이 에러로 끝나 버린다. 
	* 위의 경우 0~9 까지 접근 가능하고, scores[10] 에 접근하면 프로그램이 에러가 난다. 

```
int index = 3;
printf("점수는 %d 입니다.", scores[index]);
printf("점수는 %d 입니다.", scores[index + 1]);
```

* [] 안에 숫자 뿐만 아니라 int 변수를 통해서도 접근 가능하다
* [] 안에 연산이 가능하고 그 결과에 따라 접근이 가능하다.

```
scores[4] = 93;
scores[9] = 72
```
* 인덱스로 접근해서 변수처럼 값을 수정 할 수 있다. 

## 반복문을 통한 접근
*  변수를 하나를 사용하여 10개의 데이터를 저장 하긴 했지만, 여전히 값을 접근하는데는 여러 라인의 명령이 필요하다. 
*  이것을 편하게 하기 위해서 반복문을 사용한다. 

```
int scores[10] = {89, 93, 91, 93, 92, 78, 90, 90, 93, 90};
for(int i = 0; i < 10; i++) {
	printf("%d ", scores[i]);
}
```

* [] 안의 index는 변수 형태로 접근이 가능하다. 
*  이를 이용해서 반복문의 i를 통해 하나씩 접근하도록 한다. 
*  위 소스 의 결과는 아래와 같다. 

```
89 93 91 93 92 78 90 90 93 90 
```
* 배열의 사용은 반복문과 같이 사용하면서 효율이 극대화가 된다. 

* 이를 정리해서 평균을 구하는 문제를 배열로 풀어 보자 

```
int scores[10] = {89, 93, 91, 93, 92, 78, 90, 90, 93, 90};
    
int sum = 0;
for(int i = 0; i < 10; i++) {
	sum += scores[i];
}
    
printf("평균은 %f 입니다.", sum / 10.0);
```
* 반복문 안에서 scores의 값을 하나씩 접근하여 sum에 더해서 저장한다. 
* 반복문이 끝나고 나서 sum에 저장 한 값을 10으로 나누어서 평균을 구한다. 

[예제 보기](ex/ex01.c)

[연습문제1](test/test01/README.md)  
[연습문제2](test/test02/README.md)  
[고급문제](test/test03/README.md)

## 여러개의 배열
*  5명의 학생의 성적의 평균을 각각 구하세요

```
int scores1[10] = {89, 93, 91, 93, 92, 78, 90, 90, 93, 90};
int scores2[10] = {91, 82, 72, 98, 92, 87, 77, 87, 74, 88};
int scores3[10] = {98, 93, 94, 91, 97, 94, 91, 96, 98, 90};
int scores4[10] = {65, 63, 57, 87, 88, 92, 78, 85, 70, 68};
int scores5[10] = {45, 50, 48, 63, 67, 58, 40, 66, 47, 64};

int sum = 0;
for(int i = 0; i < 10; i++) {
    sum += scores1[i];
}

printf("1번 학생의 평균은 %f 입니다.\n", sum / 10.0);

sum = 0;
for(int i = 0; i < 10; i++) {
    sum += scores2[i];
}

printf("2번 학생의 평균은 %f 입니다.\n", sum / 10.0);

sum = 0;
for(int i = 0; i < 10; i++) {
    sum += scores3[i];
}

printf("3번 학생의 평균은 %f 입니다.\n", sum / 10.0);

sum = 0;
for(int i = 0; i < 10; i++) {
    sum += scores4[i];
}

printf("4번 학생의 평균은 %f 입니다.\n", sum / 10.0);
```
* 위와 같이 같은 속성의 배열을 여러개 사용할 경우가 생긴다.
* 변수를 여러개 썻을 때와 마찬가지로 라인 수가 많아지고 , 가독성이 떨어지고, 에러 확률도 높아 진다. 

## 2차원 배열
* 위의 배열 들을 아래와 같이 표현 할 수 있다. 

```
int scores[5][10] = {
    {89, 93, 91, 93, 92, 78, 90, 90, 93, 90},
    {91, 82, 72, 98, 92, 87, 77, 87, 74, 88},
    {98, 93, 94, 91, 97, 94, 91, 96, 98, 90},
    {65, 63, 57, 87, 88, 92, 78, 85, 70, 68},
    {45, 50, 48, 63, 67, 58, 40, 66, 47, 64}
};
```
* 배열 안에 배열이 자리 잡은 형태로 **2차원 배열** 이라고 한다. 
* 이와 대비 되어 하나의 배열로 된것을 **1차원 배열** 이라고 한다.
* 2차원 배열은 여러개의 1차원 배열을 가진 배열이다. 
* 변수 이름 뒤에 [ ][ ] 두개의 범위가 지정이 된다.
* 첫 번째 범위는 저장 할 1차원 배열의 개수를 의미한다
* 두 번째 범위는 저장 한 1차원배열의 크기를 의미한다. 
* 1차원 배열의 크기는 모두 동일해야 한다. 
*  큰 중괄호 안에 여러개의 배열이 들어 간다, 
*  각 배열이 자리하고 배열 사이에 ,(쉼표)로 구분된다.
* 중첩 반복문 처럼 배열 각각을 개별 적으로 생각 하고, 그 개별적인 것들의 집합 이라고 생각 해야 한다.

```
int scores[2][3] = {
    {89, 93, 83}, 
    {0, }
};
```
* 각 배열은 기존 처럼 초기화가 가능하다.

## 배열 값의 접근 
```
printf("첫번째 학생의 첫번쨰 값은 %d 입니다.", scores[0][0]);
printf("첫번째 학생의 두번쨰 값은 %d 입니다.", scores[0][1]);
printf("첫번째 학생의 세번쨰 값은 %d 입니다.", scores[0][2]);
printf("첫번째 학생의 네번쨰 값은 %d 입니다.", scores[0][3]);

printf("네번째 학생의 첫번쨰 값은 %d 입니다.", scores[3][0]);
printf("네번째 학생의 두번쨰 값은 %d 입니다.", scores[3][1]);
printf("네번째 학생의 세번쨰 값은 %d 입니다.", scores[3][2]);
printf("네번째 학생의 네번쨰 값은 %d 입니다.", scores[3][3]);
```
* 몇 번째 배열에 값을 접근 할것인지를 첫번째 에 넣는다.
* 해당 배열에서 몇 번째 값을 첩근 할 것인지를 두번째에 넣는다. 
* [ ] 안에 숫자 뿐만 아니라 int 변수를 통해서도 접근 가능하다
* [ ] 안에 연산이 가능하고 그 결과에 따라 접근이 가능하다.
* 인덱스로 접근해서 변수처럼 값을 수정 할 수 있다. 


## 반복문을 통한 접근 
* 1차원 배열과 마찬 가지로 반복문을 통한 접근이 효율적이다. 
* 2차원 배열 이므로 중첩 반복문이 효율 적이다. 

```
for(int i = 0; i < 5; i++) {  // 배열의 개수 만큼 반복
    int sum = 0;
    for(int j = 0; j < 10; j++) {  // 1차원 배열내의 개수 만큼 반복
        sum += scores[i][j];
    }
    
    printf("%d번 학생의 평균은 %f 입니다.\n", i + 1, sum / 10.0);
}
```
* 위와 같이 사용 하는 것이 일반적인 사용 법이다. 
* 큰 반복문에서 배열의 개수 만큼 반복 하도록 한다. 
* 작은 반복문에서 안에 있는 1차원배열의 크기 만큼 반복 하도록 한다. 
* 작은 반복문 안에서는 각 배열에 수행될 수행문이 자리한다. 
*  큰 반복문 안에서는 작은 반복문이 수행되도록 하고, 작은 반복문에서 필요한 초기화를 해준다.
*  큰 반복문에서 i 작은 반복문에서 j를 사용하는 것이 통상적이다. 


[연습문제1](test/test04/README.md)  
[연습문제2](test/test05/README.md)  